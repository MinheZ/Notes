* [红黑树](#红黑树)
    * [1 平衡树和非平衡树](#平衡树和非平衡树)
    * [2 旋转](#旋转)
* [2-3-4树](#2-3-4树)
    * [1 插入](#插入)
    * [2 2-3-4树转变为红黑树](#2-3-4树转变为红黑树)
    * [3 2-3-4树的效率](#2-3-4树的效率)
    * [4 2-3树](#2-3树)
    * [5 B-树](#B-树)
* [哈希表](#哈希表)

-----------------------

# 红黑树
红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet.解决非平衡树问题的方法。主要讨论插入操作。

**自顶向下插入：**

在搜索例程沿着树向下查找插入点，在此进程中可能要对树的结构做一些改变。

## 平衡树和非平衡树
创建一颗只有一个节点的树，然后插入一系列升序或者降序的关键字。如下图
<div align="center"><img src="../pics//1547174373(1).png" width="400px"></div>
这些节点排在一条直线上，没有分支，所有的节点都在根的一侧，这棵树属于极端不平衡的情况。

### 时间复杂度降低到O(N)
当树没有分支的时候，就相当于一个链表。对于随机数据的实际数量来说，一颗特别不平衡的情况不太可能，因此部分非平衡树的时间介于O(N)和Olog(N)之间，这取决于树的不平衡程度。

### 红黑树的特征
- 节点都有颜色。
- 在插入和删除的过程中，要遵循保持这些颜色的不同排列规则。

**红-黑规则**

插入（删除）一个新节点都要遵循的规则：
- 每一个节点不是红色的就是黑色的；
- 根节点总是黑色的；
- 如果节点是红色的，则他的子节点必须是黑色的；
- 从根到叶节点(没有子节点)或空子节点的每条路径，都必须包含相同数目的黑色节点。

在从根到叶节点路径上黑色节点的数目称为 **黑色高度(black height)**。

### 修正违规的情况
假设看到颜色的规则被违犯了，有且只有下列2种的修正措施：
- 改变节点的颜色；
- 执行旋转操作

## 旋转
旋转必须做2件事：
- 使一些节点上升，一些节点下降，帮助树平衡；
- 保证不破坏二叉搜索树的特征；

选择则一个节点作为旋转的“顶端”。如果做一次右旋，这个顶端节点将会移动到它右子节点的位置，左子节点将会移动到它原来的位置（必须确保右旋必须有一个左子节点）。左旋类似。**旋转不会改变每颗子树中节点的相互关系**。

**推荐文章：**
- [漫画：什么是红黑树](https://juejin.im/post/5a27c6946fb9a04509096248#comment)
- [红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)

-------------------------
# 2-3-4树
## 2-3-4树的介绍
2-3-4树，就是多叉树。它的每个节点最多有4个子节点和3个数据项。
<div align="center"><img src="../pics//1547517555(1).jpg" width="800px"></div>
2-3-4树中所有的叶节点总是在同一层上。非叶节点的子节点数总是比它含有的数据项多1。

**用符号可表示为：** L=D+1

2-3-4树的节点如下：
<div align="center"><img src="../pics//1547518687(1).jpg" width="500px"></div>

### 2-3-4树的组织
用0~2的数字给数据项编号，0~3的数字给子节点链编号 。2-3-4树的关键字存储顺序跟二叉树一样，但是新增了如下图的规则：
<div align="center"><img src="../pics//1547519007(1).jpg" width="500px"></div>

## 插入
查找时没有碰到**满节点**时，插入很简单。找到合适的叶节点后，只要把心数据项插入进去就可以了：
<div align="center"><img src="../pics//1547520090(1).jpg" width="600px"></div>

### 节点分裂
如果在寻找要插入位置的路途中，节点已经满了。这种情况下必须分裂(split)。把要分裂的节点中数据项设为A、B、C。下面是分裂时的情况（**假设分裂的节点不是根**）:
- 创建一个新的空节点。它是要分裂节点的兄弟，要放在分裂节点的右边。
- 数据项C移到新节点中。
- 数据项B移到要分裂节点的父节点中。
- 数据项A保留在原来的位置上。
- 最右边的两个子节点从分裂节点处断开，连接到新的节点上。
<div align="center"><img src="../pics//1547520399(1).png" width="700px"></div>
插入只需要分裂一个节点，除非插入路径上存在不止一个满的节点。这种情况需要多重分裂。

### 根的分裂
如果一开始查找插入点就碰到满的根时：
- 创建新的根。它是要分裂节点的父节点。
- 创建第二个新节点。它是要分裂节点的兄弟节点。
- 数据项C移动到新的兄弟节点中。
- 数据项B移动到新的根节点中。
- 数据项A保留在原来的位置上。
- 要分裂的节点最右边两个子节点断开连接，连接到新的兄弟节点上。
<div align="center"><img src="../pics//1547520780(1).png" width="700px"></div>

### 在下行路途中分裂
所有满的节点都是在下行路中分裂的。下面显示的是空树中的一系列插入过程。有4个节点分裂了，2个是根，2个是叶节点。
<div align="center"><img src="../pics//1547521301(1).png" width="700px"></div>

## 2-3-4树转变为红黑树
应用三条规则可以吧2-3-4树转变为红黑树：
- 把2-3-4树中的每个2-节点转化为红黑树的黑色节点；
- 把每个3-节点转化为一个子节点和一个父节点。子节点有2个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色；
- 把每个4-节点转化成一个度节点和两个子节点。第一个子节点有它自己的子节点W和X，第二个子节点拥有子节点Y和Z。子节点涂成红色，父节点涂成黑色。
<div align="center"><img src="../pics//1547542271.png" width="700px"></div>
2-3-4树转化为红黑树实例：
<div align="center"><img src="../pics//1547542349(1).png" width="700px"></div>
可以想象为抓着中间的数据项，把整棵树“拎”起来。

## 2-3-4树的效率
2-3-4树中每个节点最多可以有4个节点，如果每个节点都是满的，树的高度和`log4(N)`成正比。因此，在所有节点都满的情况下2-3-4树的高度是红黑树的一半。不过他们不可能是满的。

2-3-4树的高度大概在`log2(N+1)`和`log2(N+1)/2`之间。但是2-3-4树每个节点要查看的数据项更多，这部分是线性查找，使得查找时间增加的倍数和`M`(每个节点的平均数据项个数)成正比。因此2-3-4树总的效率与`M*log4(N)`成正比。

2-3-4树中每个节点的数据项都不一样，按照平均2个来计算的话，查找时间与`2*log4(N)`成正比，在大O表示法中这个小的常数可以忽略。

因此，2-3-4树增加每个节点的数据项数量可以抵偿树高度的减小。总的查找时间与红黑树相当，都是`Olog(N)`。

## 2-3树
相比2-3-4树，节点数据项和子节点个数都少1。父节点和子节点的关键字排序顺序和2-3-4树保持一致。

### 节点分裂
2-3树中新的数据项必须参与分裂的过程：如果新数据项要插入的叶节点不满，则可以立即插进去，如果叶节点满了，该节点就得分裂。该节点的两个数据项和新数据项分在这三个节点里：已存在的节点、新节点和父节点。如果父节点非满，操作完成。
<div align="center"><img src="../pics//1547606636(1).png" width="500px"></div>
否则继续分裂父节点。
<div align="center"><img src="../pics//1547606859(1).png" width="500px"></div>
如果根节点也是满的，则创建一个新的根作为原来根的父节点。
<div align="center"><img src="../pics//1547607432(1).png" width="500px"></div>
下图则是展示一颗2-3树顺着向上延续分裂节点直到达到根位置的情况：
<div align="center"><img src="../pics//1547607691(1).png" width="500px"></div>
补充：每次分裂的详细情况
<div align="center"><img src="../pics//1547608206(1).png" width="500px"></div>

## B-树
类似于2-3-4树，但是每个节点有**更多的数据项**。B-树的阶数由节点拥有最多的子节点数决定。

**插入:**B-树当中的节点尽可能地满
- 节点分裂时数据项平分：一半到新创建的节点中去，一半保留在原来的节点中。
- 节点分裂像2-3树一样**从底向上**，而不是自顶上下。
- 同样，还是像2-3树一样，原节点内中间数据项不上移，而是加上数据项后锁组成的节点数据项序列的中间数据项上移。(也就是先插入后上移！)

B-树的插入过程如下：
<div align="center"><img src="../pics//1547633420(1).png" width="600px"></div>
只有一个新的数据项插入到满的节点中时，才需要分裂节点。
<div align="center"><img src="../pics//1547633749(1).png" width="600px"></div>

**注意：** 在整个插入过程中，没有一个节点(除了根节点)的数据项少于一般，并且很多都比一半要满。这样做能够使读取一个节点时，总是能存取尽可能多的数据。

<!-- ### B-树的效率 -->
# 哈希表
**优点：** 不论哈希表中有多少数据，插入和删除(有时候包括删除)只需要接近常量的时间O(1)

**缺点：**基于数组，创建后难以扩展。无法简单地顺序遍历表中的数据项。

在不需要有序遍历数据，且可以预知数据量大小，哈希表能充分展现它的性能。

## 哈希化
把要存储的值，通过某种变换转化成数组下标。(类似于某种归一化)

### 冲突
把巨大的数字空间压缩成较小的数字空间，怎么样保证每个数据都映射到数组的控制单元？**一般设定的数组容量是需求容量的两倍**。因此，当冲突发生时：
- 一个方法是通过系统的方法找到数组的一个空位，并把这个数据项填入，而不再使用哈希函数得到数组下标——**开放地址法**
- 创建一个存放数据链表的数组，数组内不直接存放数据。当冲突发生的时候，新的数据项直接接到这个数组下标所指的链表中——**链地址法**
-
